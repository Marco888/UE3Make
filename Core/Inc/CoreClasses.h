/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if ((_MSC_VER) || (HAVE_PRAGMA_PACK))
#pragma pack (push,OBJECT_ALIGNMENT)
#endif

#ifndef CORE_API
#define CORE_API DLL_IMPORT
#endif

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern CORE_API FName CORE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

#ifndef NAMES_ONLY

class CORE_API USubsystem : public UObject, public FExec
{
public:
	DECLARE_ABSTRACT_CLASS(USubsystem,UObject,0,Core)

	virtual void Tick( FLOAT DeltaTime )
	{}
};

class CORE_API ULocale : public UObject
{
public:
	DECLARE_CLASS(ULocale,UObject,CLASS_Transient,Core)
	NO_DEFAULT_CONSTRUCTOR(ULocale)
};

class UMetaData : public UObject
{
	DECLARE_CLASS(UMetaData, UObject, 0, Core)

#if 1
	// Variables.
	TMap<UObject*, TMap<FName, FString> > ObjectMetaDataMap;

	// UObject interface.
	void Serialize(FArchive& Ar);

	// MetaData utility functions
	/**
	 * Return the value for the given key in the given property
	 * @param Object the object to lookup the metadata for
	 * @param Key The key to lookup
	 * @return The value if found, otherwise an empty string
	 */
	const FString& GetValue(const UObject* Object, const TCHAR* Key);

	/**
	 * Return the value for the given key in the given property
	 * @param Object the object to lookup the metadata for
	 * @param Key The key to lookup
	 * @return The value if found, otherwise an empty string
	 */
	const FString& GetValue(const UObject* Object, FName Key);

	/**
	 * Return whether or not the Key is in the meta data
	 * @param Object the object to lookup the metadata for
	 * @param Key The key to query for existence
	 * @return TRUE if found
	 */
	UBOOL HasValue(const UObject* Object, const TCHAR* Key);

	/**
	 * Return whether or not the Key is in the meta data
	 * @param Object the object to lookup the metadata for
	 * @param Key The key to query for existence
	 * @return TRUE if found
	 */
	UBOOL HasValue(const UObject* Object, FName Key);

	/**
	 * Is there any metadata for this property?
	 * @param Object the object to lookup the metadata for
	 * @return TrUE if the object has any metadata at all
	 */
	UBOOL HasObjectValues(const UObject* Object);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param Object the object to set the metadata for
	 * @Values The metadata key/value pairs
	 */
	void SetObjectValues(const UObject* Object, const TMap<FName, FString>& Values);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param Object the object to set the metadata for
	 * @param Key A key to set the data for
	 * @param Value The value to set for the key
	 * @Values The metadata key/value pairs
	 */
	void SetValue(const UObject* Object, const TCHAR* Key, const FString& Value);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param Object the object to set the metadata for
	 * @param Key A key to set the data for
	 * @param Value The value to set for the key
	 * @Values The metadata key/value pairs
	 */
	void SetValue(const UObject* Object, FName Key, const FString& Value);

	/**
	 * Method to help support metadata for intrinsic classes. Attempts to find and set meta data for a given intrinsic class and subobject
	 * within an ini file. The keys in the ini file are expected to be in the format of ClassToUseName.ObjectToUseName, where all of the characters
	 * in the names are alphanumeric.
	 *
	 * @param	ClassToUse			Intrinsic class to attempt to find meta data for
	 * @param	ObjectToUse			Sub-object, such as a property or enum, of the provided intrinsic class
	 * @param	MetaDataToAddTo		Metadata object that any parsed metadata found in the ini will be added to
	 *
	 * @return	TRUE if any data was found, parsed, and added; FALSE otherwise
	 */
	static UBOOL AttemptParseIntrinsicMetaData(const UClass& ClassToUse, const UObject& ObjectToUse, UMetaData& MetaDataToAddTo);

	/**
	 * Removes any metadata entries that are to objects not inside the same package as this UMetaData object.
	 */
	void RemoveMetaDataOutsidePackage();
#else
	// Variables.
	TMap<FString, TMap<FName, FString> > Values;

	// UObject interface.
	void Serialize(FArchive& Ar);

	// MetaData utility functions
	/**
	 * Return the value for the given key in the given property
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key The key to lookup
	 * @return The value if found, otherwise an empty string
	 */
	const FString& GetValue(const FString& ObjectPath, FName Key);

	/**
	 * Return the value for the given key in the given property
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key The key to lookup
	 * @return The value if found, otherwise an empty string
	 */
	const FString& GetValue(const FString& ObjectPath, const TCHAR* Key);

	/**
	 * Return whether or not the Key is in the meta data
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key The key to query for existence
	 * @return TRUE if found
	 */
	UBOOL HasValue(const FString& ObjectPath, FName Key);

	/**
	 * Return whether or not the Key is in the meta data
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key The key to query for existence
	 * @return TRUE if found
	 */
	UBOOL HasValue(const FString& ObjectPath, const TCHAR* Key);

	/**
	 * Is there any metadata for this property?
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @return TrUE if the object has any metadata at all
	 */
	UBOOL HasObjectValues(const FString& ObjectPath);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @Values The metadata key/value pairs
	 */
	void SetObjectValues(const FString& ObjectPath, const TMap<FName, FString>& Values);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key A key to set the data for
	 * @param Value The value to set for the key
	 * @Values The metadata key/value pairs
	 */
	void SetValue(const FString& ObjectPath, FName Key, const FString& Value);

	/**
	 * Set the key/value pair in the Property's metadata
	 * @param ObjectPath The path name (GetPathName()) to the object in this package to lookup in
	 * @param Key A key to set the data for
	 * @param Value The value to set for the key
	 * @Values The metadata key/value pairs
	 */
	void SetValue(const FString& ObjectPath, const TCHAR* Key, const FString& Value);
#endif
};

class UComponent : public UObject
{
	DECLARE_CLASS(UComponent, UObject, 0, Core);

public:
	class UClass* TemplateOwnerClass;
	FName TemplateName;

	/**
	 * @return if this object is a UComponent or subclass
	 */
	UBOOL IsAComponent() const
	{
		return TRUE;
	}
	virtual UComponent* ResolveSourceDefaultObject();
	virtual void PreSerialize(FArchive& Ar);

	UBOOL IsInstanced() const
	{
		UBOOL bResult = FALSE;

		// TemplateName should only be none if the component wasn't instanced
		if (TemplateName != NAME_None)
			// components whose Outer is a CDO should never be considered instanced
			bResult = !GetOuter()->HasAnyFlags(RF_ClassDefaultObject);
		return bResult;
	}
	FName UComponent::GetInstanceMapName() const
	{
		FName InstanceMapName = GetFName();
		if (IsInstanced())
			InstanceMapName = TemplateName;
		return InstanceMapName;
	}
	void LinkToSourceDefaultObject(UComponent* OriginalComponent, UClass* OwnerClass, FName ComponentName);

	UComponent(){}
};

class UDistributionFloat : public UComponent
{
public:
	void* VfTable_FCurveEdInterface GCC_PACK(INT_ALIGNMENT);
	BITFIELD bCanBeBaked : 1 GCC_PACK(INT_ALIGNMENT);
	BITFIELD bIsDirty : 1;

	DISABLE_SERIALIZATION;

	DECLARE_CLASS(UDistributionFloat, UComponent, CLASS_Abstract, Core);
	NO_DEFAULT_CONSTRUCTOR(UDistributionFloat);
};
class UDistributionVector : public UComponent
{
public:
	void* VfTable_FCurveEdInterface GCC_PACK(INT_ALIGNMENT);
	BITFIELD bCanBeBaked : 1 GCC_PACK(INT_ALIGNMENT);
	BITFIELD bIsDirty : 1;

	DISABLE_SERIALIZATION;

	DECLARE_CLASS(UDistributionVector, UComponent, CLASS_Abstract, Core);
	NO_DEFAULT_CONSTRUCTOR(UDistributionVector);
};

class UObjectRedirector : public UObject
{
	DECLARE_NOINST_CLASS(UObjectRedirector, UObject, 0, Core);
};

template < class T > class TArchiveObjectReferenceCollector : public FArchive
{
public:

	/**
	 * Constructor
	 *
	 * @param	InObjectArray			Array to add object references to
	 * @param	InOuter					value for LimitOuter
	 * @param	bInRequireDirectOuter	value for bRequireDirectOuter
	 * @param	bShouldIgnoreArchetype	whether to disable serialization of ObjectArchetype references
	 * @param	bInSerializeRecursively	only applicable when LimitOuter != NULL && bRequireDirectOuter==TRUE;
	 *									serializes each object encountered looking for subobjects of referenced
	 *									objects that have LimitOuter for their Outer (i.e. nested subobjects/components)
	 * @param	bShouldIgnoreTransient	TRUE to skip serialization of transient properties
	 */
	TArchiveObjectReferenceCollector(TArray<T*>* InObjectArray, UObject* InOuter = NULL, UBOOL bInRequireDirectOuter = TRUE, UBOOL bShouldIgnoreArchetype = FALSE, UBOOL bInSerializeRecursively = FALSE, UBOOL bShouldIgnoreTransient = FALSE)
		: ObjectArray(InObjectArray)
		, LimitOuter(InOuter)
		, bRequireDirectOuter(bInRequireDirectOuter)
	{
		ArIsPersistent = bShouldIgnoreTransient;
		//ArIgnoreArchetypeRef = bShouldIgnoreArchetype;
		bSerializeRecursively = bInSerializeRecursively && LimitOuter != NULL;
	}
protected:

	/**
	 * UObject serialize operator implementation
	 *
	 * @param Object	reference to Object reference
	 * @return reference to instance of this class
	 */
	FArchive& operator<<(UObject*& Object)
	{
		// Avoid duplicate entries.
		if (Object != NULL)
		{
			if (LimitOuter == NULL || (Object->GetOuter() == LimitOuter || (!bRequireDirectOuter && Object->IsIn(LimitOuter))))
			{
				// do not attempt to serialize objects that have already been 
				if (Object->IsA(T::StaticClass()) && ObjectArray->FindItemIndex((T*)Object) == INDEX_NONE)
				{
					ObjectArray->AddItem((T*)Object);
				}

				// check this object for any potential object references
				if (bSerializeRecursively == TRUE && !SerializedObjects.Find(Object))
				{
					SerializedObjects.Set(Object);
					Object->Serialize(*this);
				}
			}
		}

		return *this;
	}

	/** Stored pointer to array of objects we add object references to */
	TArray<T*>* ObjectArray;

	/** List of objects that have been recursively serialized */
	TSingleMap<UObject*>	SerializedObjects;

	/** only objects within this outer will be considered, NULL value indicates that outers are disregarded */
	UObject* LimitOuter;

	/** determines whether nested objects contained within LimitOuter are considered */
	UBOOL			bRequireDirectOuter;

	/** determines whether we serialize objects that are encounterd by this archive */
	UBOOL			bSerializeRecursively;
};

#endif

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif // NAMES_ONLY

#if ((_MSC_VER) || (HAVE_PRAGMA_PACK))
#pragma pack (pop)
#endif

#ifdef VERIFY_CLASS_SIZES
#endif // VERIFY_CLASS_SIZES
